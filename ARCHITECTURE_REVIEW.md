## Архитектурный обзор Modern UART Control

Этот файл фиксирует текущее состояние архитектуры проекта, сильные и слабые стороны, а также план дальнейших улучшений с упором на производительность и безопасность.

### Плюсы архитектуры

- **Чёткое разделение слоёв (MVVM)**  
  View (`MainWindow`, `PortPanelView`, `ConsolePanelView`, диалоги) изолированы от бизнес‑логики (`ComPortViewModel`, `MainViewModel`, `SerialWorker`), что упрощает сопровождение и развитие.

- **Асинхронная работа с COM‑портами**  
  Класс `SerialWorker` реализован на базе `QThread` с очередью записи и сигналами для UI, что защищает главный поток от блокировок ввода‑вывода.

- **Учет производительности в консоли**  
  `ConsolePanelView` использует:
  - троттлинг обновлений через `QTimer`;
  - ограничения `ConsoleLimits` на длину HTML и число строк;
  - кэш логов с обрезанием старых записей.  
  Это снижает риск утечек памяти и лагов при большом объёме телеметрии.

- **Безопасное отображение данных**  
  Для логов и истории команд применяется экранирование HTML (`html.escape` и аналогичная логика), что предотвращает XSS‑подобные артефакты в UI.

- **Гибкая конфигурация через `config.ini` и JSON**  
  Размеры, шрифты, цвета и параметры последовательного порта вынесены в конфиг, что позволяет настраивать приложение без правок кода.

- **Система тем и переводов**  
  Единый `ThemeManager` + словарь `STRINGS` обеспечивают:
  - лёгкое добавление новых тем;
  - централизованное переключение языка UI;
  - единообразие текстов.

- **Ограничения и защита в `SerialWorker`**  
  Реализованы:
  - лимит буфера и rate‑limiting по RX/TX;
  - защита от CRLF‑инъекций в отправляемых данных;
  - явное ограничение размера пакетов и очереди.  
  Это снижает риски DoS через переполнение буферов и некорректные последовательности символов.

### Минусы и потенциальные риски

- **Синхронная запись истории команд на диск при каждом отправлении**  
  `CommandHistoryModel.add_entry()` вызывает `save()` на каждый ввод команды, что ведёт к частым синхронным операциям с JSON‑файлом в главном потоке и может вызывать микролаги при активном использовании.

- **Версия проекта вычисляется через `git` при импорте модуля**  
  `src/version.py` выполняет `subprocess.check_output` при импорте, что:
  - замедляет холодный старт;
  - зависит от наличия git и корректного репозитория.  
  Это эксплуатационный риск и потенциальный источник задержек при старте.

- **Потенциальный перерасход памяти на логи**  
  `ConsolePanelView` и `MainViewModel` хранят кэш логов (HTML + plain) с порогами порядка 10 000 строк. При трёх активных портах и длительном сеансе это может занимать заметный объём RAM.

- **Неполная консистентность API `SerialWorker.write_bytes`**  
  Метод `write_bytes()` добавляет в очередь байты, а `_send_data()` ожидает строку и выполняет операции `rstrip`, проверки на `\n`/`\r` и кодирование, что делает поведение байтового интерфейса неоднозначным и потенциально ошибочным.

- **Жёстко зашитые пути к файлам конфигурации**  
  Пути к `config/command_history.json`, `config/transmission_settings.json`, `config.ini` жёстко рассчитываются от `__file__`. Это нормально в режиме разработки, но потребует дополнительной обработки при упаковке в дистрибутив или при изменении структуры каталогов.

### Замечания и план улучшений

#### 1. Оптимизировать сохранение истории команд

- **Проблема**: синхронная запись JSON на каждый вызов `add_entry()` блокирует главный поток и фонд работы с диском.  
- **План**:
  1. В `CommandHistoryModel` ввести буфер несохранённых изменений и таймер (например, `QTimer` с интервалом 500–1000 мс).
  2. При добавлении записи только помечать модель как «грязную» и откладывать фактический `save()` до срабатывания таймера или до закрытия приложения.
  3. Добавить явный метод `flush()` и вызывать его из `MainWindow.closeEvent` для гарантированного сохранения истории при выходе.

#### 2. Сделать вычисление версии ленивым и/или статичным

- **Проблема**: вызов `git describe` в `src/version.py` при импорте замедляет старт и зависит от окружения.  
- **План**:
  1. Заменить вычисление версии на:
     - либо ленивое (вычислять при первом вызове `get_version()` и кэшировать результат);
     - либо статичное (подставлять версию на этапе сборки/релиза).
  2. Добавить таймаут к `subprocess.check_output` на случай зависаний git.

#### 3. Управление объёмом логов в консоли

- **Проблема**: при длительной работе возможен рост потребления памяти за счёт кэша и содержимого `QTextDocument`, несмотря на существующие ограничения.  
- **План**:
  1. Вынести `MAX_CACHE_LINES`, `MAX_DOCUMENT_LINES` и `MAX_HTML_LENGTH` в конфигурационный файл.
  2. По умолчанию уменьшить пороги (например, до 2–5 тыс. строк на порт) и документировать, как их повышать при необходимости.
  3. Добавить опциональный «режим низкой памяти», при котором хранится только последняя часть лога без полного кэша для поиска.

#### 4. Уточнить контракт для `SerialWorker.write_bytes`

- **Проблема**: байтовый интерфейс не соответствует фактической реализации `_send_data`, что может приводить к скрытым ошибкам.  
- **План**:
  1. Явно определить, нужен ли байтовый API. Если нет — удалить `write_bytes()` или пометить как внутренний/устаревший.
  2. Если байтовый API необходим — реализовать отдельный путь отправки байтов:
     - без манипуляций с `\r\n`;
     - с учётом тех же лимитов по длине и rate‑limiting;
     - с чёткой документацией, что ответственность за формат кадра лежит на вызывающем коде.

#### 5. Подготовить пути конфигурации к упаковке приложения

- **Проблема**: жёстко заданные пути на основе `__file__` усложняют упаковку (PyInstaller, cx_Freeze и т.п.) и переносимость.  
- **План**:
  1. Ввести единый модуль `paths`/`app_dirs`, который:
     - определяет каталог конфигурации для разработки (рядом с исходниками);
     - и альтернативный путь для установленных/упакованных сборок (например, `%APPDATA%/UART_CTRL`).
  2. Перевести `CommandHistoryModel`, `transmission_settings`, `ConfigLoader` и `ThemeManager` на использование этого модуля.
  3. Добавить краткое описание этой логики в `README.md`.

#### 6. Повысить наблюдаемость ошибок конфигурации

- **Проблема**: при ошибках чтения/записи конфигурационных файлов в большинстве мест используется молчаливый fallback, что усложняет диагностику проблем у пользователя.  
- **План**:
  1. В модулях `config_loader`, `transmission_settings`, `CommandHistoryModel` и т.п. логировать ошибки через `logging` с уровнем `WARNING`/`ERROR`.
  2. Для критичных отказов (невозможно записать историю, настройки передачи и т.п.) дополнительно выводить пользовательское уведомление в UI.
  3. Явно задокументировать поведение по умолчанию в `README.md`.

